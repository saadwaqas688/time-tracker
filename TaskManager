package org.example;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

public class TaskManager extends JFrame {

    private static final int UPDATE_INTERVAL_MS = 1000; // 1 second
    private static final String FILE_PATH = "user-activity.txt";

    private final Map<Integer, TaskData> tasks = new HashMap<>();
    private Integer currentRunningTaskId = null;

    private final JLabel task1Label = new JLabel("Task 1: 0 s");
    private final JLabel task2Label = new JLabel("Task 2: 0 s");
    private final JLabel task3Label = new JLabel("Task 3: 0 s");

    public TaskManager() {
        setTitle("Task Manager");
        setSize(400, 300);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new GridLayout(5, 2));

        JButton task1StartButton = new JButton("Start Task 1");
        JButton task1StopButton = new JButton("Stop Task 1");
        JButton task2StartButton = new JButton("Start Task 2");
        JButton task2StopButton = new JButton("Stop Task 2");
        JButton task3StartButton = new JButton("Start Task 3");
        JButton task3StopButton = new JButton("Stop Task 3");

        add(task1StartButton);
        add(task1StopButton);
        add(task2StartButton);
        add(task2StopButton);
        add(task3StartButton);
        add(task3StopButton);
        add(task1Label);
        add(task2Label);
        add(task3Label);

        task1StartButton.addActionListener(new TaskActionListener(1, true));
        task1StopButton.addActionListener(new TaskActionListener(1, false));
        task2StartButton.addActionListener(new TaskActionListener(2, true));
        task2StopButton.addActionListener(new TaskActionListener(2, false));
        task3StartButton.addActionListener(new TaskActionListener(3, true));
        task3StopButton.addActionListener(new TaskActionListener(3, false));

        // Load tasks from file and adjust running tasks
        loadTasksFromFile();

        Timer updateTimer = new Timer(UPDATE_INTERVAL_MS, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                updateTasks();
                writeToFile();
                updateLabels();
            }
        });
        updateTimer.start();
    }

    private class TaskData {
        long timeStamp;
        boolean isRunning;
        long timeSpent;

        TaskData(long timeStamp, boolean isRunning, long timeSpent) {
            this.timeStamp = timeStamp;
            this.isRunning = isRunning;
            this.timeSpent = timeSpent;
        }
    }

    private class TaskActionListener implements ActionListener {
        private final int taskId;
        private final boolean start;

        TaskActionListener(int taskId, boolean start) {
            this.taskId = taskId;
            this.start = start;
        }

        @Override
        public void actionPerformed(ActionEvent e) {
            long currentTime = Instant.now().toEpochMilli();

            if (start) {
                if (currentRunningTaskId != null && !currentRunningTaskId.equals(taskId)) {
                    stopTask(currentRunningTaskId, currentTime);
                }

                // Start new task
                TaskData existingTaskData = tasks.get(taskId);
                if (existingTaskData == null) {
                    existingTaskData = new TaskData(currentTime, true, 0);
                } else {
                    existingTaskData.isRunning = true;
                    existingTaskData.timeStamp = currentTime;
                }
                tasks.put(taskId, existingTaskData);
                currentRunningTaskId = taskId;

                // Write immediately to file
                writeToFile();

                System.out.println("Started: Task " + taskId);
            } else {
                if (currentRunningTaskId != null && currentRunningTaskId.equals(taskId)) {
                    stopTask(taskId, currentTime);
                } else {
                    System.out.println("Task " + taskId + " is not running.");
                }
            }
        }
    }

    private void stopTask(int taskId, long currentTime) {
        TaskData taskData = tasks.get(taskId);
        if (taskData != null && taskData.isRunning) {
            taskData.isRunning = false;
            taskData.timeSpent += (currentTime - taskData.timeStamp) / 1000; // convert ms to s
            taskData.timeStamp = currentTime;
            tasks.put(taskId, taskData);
            System.out.println("Stopped: Task " + taskId + " - Total Time: " + taskData.timeSpent + " s");
            currentRunningTaskId = null;
        }
    }

    private void updateTasks() {
        long currentTime = Instant.now().toEpochMilli();
        for (Map.Entry<Integer, TaskData> entry : tasks.entrySet()) {
            TaskData taskData = entry.getValue();
            if (taskData.isRunning) {
                taskData.timeSpent += (currentTime - taskData.timeStamp) / 1000; // convert ms to s
                taskData.timeStamp = currentTime;
            }
        }
    }

    private void writeToFile() {
        System.out.println("Writing to file...");
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(FILE_PATH, false))) { // 'false' to overwrite the file
            for (Map.Entry<Integer, TaskData> entry : tasks.entrySet()) {
                int taskId = entry.getKey();
                TaskData taskData = entry.getValue();
                writer.write(taskId + ": {timeStamp:" + taskData.timeStamp + ", isRunning:" + taskData.isRunning +
                        ", timeSpent:" + taskData.timeSpent + " s}\n");
            }
            writer.flush();
            System.out.println("Data written to file.");
        } catch (IOException e) {
            System.err.println("Error writing to file: " + e.getMessage());
            e.printStackTrace();
        }
    }


    private void updateLabels() {
        task1Label.setText("Task 1: " + tasks.getOrDefault(1, new TaskData(0, false, 0)).timeSpent + " s");
        task2Label.setText("Task 2: " + tasks.getOrDefault(2, new TaskData(0, false, 0)).timeSpent + " s");
        task3Label.setText("Task 3: " + tasks.getOrDefault(3, new TaskData(0, false, 0)).timeSpent + " s");
    }


    private void loadTasksFromFile() {
        System.out.println("Loading tasks from file...");
        tasks.clear(); // Clear current tasks to avoid stale data

        try (BufferedReader reader = new BufferedReader(new FileReader(FILE_PATH))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // Debugging output to see the raw line read
                System.out.println("Raw line from file: " + line);

                // Split the line into task ID and data part
                String[] parts = line.split(": \\{");
                if (parts.length < 2) {
                    System.err.println("Skipping malformed line: " + line);
                    continue;
                }

                // Extract task ID
                int taskId = Integer.parseInt(parts[0].trim());

                // Extract task data part and remove ending curly brace
                String taskDataStr = parts[1].trim().replace("}", "").trim();
                String[] data = taskDataStr.split(", ");

                long timeStamp = 0;
                boolean isRunning = false;
                long timeSpent = 0;

                for (String item : data) {
                    // Split item into key and value
                    String[] keyValue = item.split(":");
                    if (keyValue.length < 2) {
                        System.err.println("Skipping malformed data item: " + item);
                        continue;
                    }

                    String key = keyValue[0].trim();
                    String value = keyValue[1].trim();

                    switch (key) {
                        case "timeStamp":
                            timeStamp = Long.parseLong(value);
                            break;
                        case "isRunning":
                            isRunning = Boolean.parseBoolean(value);
                            break;
                        case "timeSpent":
                            timeSpent = Long.parseLong(value.replace(" s", ""));
                            break;
                        default:
                            System.err.println("Unknown key: " + key);
                            break;
                    }
                }

                TaskData taskData = new TaskData(timeStamp, isRunning, timeSpent);

                // If the task is running, update timeSpent and timeStamp
                if (isRunning) {
                    long currentTime = Instant.now().toEpochMilli();
//                    taskData.timeSpent += (currentTime - timeStamp) / 1000; // convert ms to s
                    taskData.timeStamp = currentTime; // Update timeStamp to current time
                    // Set currentRunningTaskId to the task that was running
                    currentRunningTaskId = taskId;
                }

                tasks.put(taskId, taskData);

                // Debug output to confirm loaded data
                System.out.println("Loaded Task ID: " + taskId);
                System.out.println("  Time Stamp: " + taskData.timeStamp);
                System.out.println("  Is Running: " + taskData.isRunning);
                System.out.println("  Time Spent: " + taskData.timeSpent + " s");
            }
            System.out.println("Tasks loaded from file.");
        } catch (IOException e) {
            System.err.println("Error reading from file: " + e.getMessage());
            e.printStackTrace();
        }
    }



    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            TaskManager tm = new TaskManager();
            tm.setVisible(true);
        });
    }
}
